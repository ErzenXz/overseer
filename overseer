#!/bin/bash

# Overseer Management Script
# This file is tracked in git - ./overseer update will keep it current.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Load environment
if [ -f ".env" ]; then
    set -a; source .env; set +a
fi

GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

is_linux() { [[ "$OSTYPE" == "linux-gnu"* ]]; }

get_port() {
    echo "${PORT:-3000}"
}

get_ip() {
    hostname -I 2>/dev/null | awk '{print $1}' || echo "localhost"
}

UPDATE_REMOTE=""
UPDATE_BRANCH=""
UPDATE_LOCAL_SHA=""
UPDATE_REMOTE_SHA=""
UPDATE_BASE_SHA=""
UPDATE_STATUS=""

resolve_tracking_ref() {
    local tracking_ref
    tracking_ref=$(git rev-parse --abbrev-ref --symbolic-full-name "@{u}" 2>/dev/null || true)

    if [ -n "$tracking_ref" ]; then
        UPDATE_REMOTE="${tracking_ref%%/*}"
        UPDATE_BRANCH="${tracking_ref#*/}"
        return 0
    fi

    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")
    UPDATE_REMOTE="origin"
    UPDATE_BRANCH="$current_branch"
}

check_for_updates() {
    if [ ! -d ".git" ]; then
        UPDATE_STATUS="not-git"
        return 0
    fi

    resolve_tracking_ref

    if ! git fetch "$UPDATE_REMOTE" "$UPDATE_BRANCH" --quiet; then
        UPDATE_STATUS="fetch-failed"
        return 0
    fi

    UPDATE_LOCAL_SHA=$(git rev-parse HEAD)
    UPDATE_REMOTE_SHA=$(git rev-parse "$UPDATE_REMOTE/$UPDATE_BRANCH")
    UPDATE_BASE_SHA=$(git merge-base HEAD "$UPDATE_REMOTE/$UPDATE_BRANCH")

    if [ "$UPDATE_LOCAL_SHA" = "$UPDATE_REMOTE_SHA" ]; then
        UPDATE_STATUS="up-to-date"
    elif [ "$UPDATE_LOCAL_SHA" = "$UPDATE_BASE_SHA" ]; then
        UPDATE_STATUS="behind"
    elif [ "$UPDATE_REMOTE_SHA" = "$UPDATE_BASE_SHA" ]; then
        UPDATE_STATUS="ahead"
    else
        UPDATE_STATUS="diverged"
    fi
}

# ---- Regenerate systemd service to match current config ----
regenerate_systemd_service() {
    if ! is_linux || ! command -v systemctl &>/dev/null; then
        return 0
    fi

    local npx_path=$(which npx)
    local port=$(get_port)
    local user=$(whoami)
    local dir="$SCRIPT_DIR"

    echo -e "    ${CYAN}>${NC} Updating systemd service file..."

    sudo tee /etc/systemd/system/overseer.service > /dev/null << SVCEOF
[Unit]
Description=Overseer AI Agent - Web Admin Dashboard
Documentation=https://github.com/ErzenXz/overseer
After=network.target
Wants=network-online.target

[Service]
Type=simple
User=${user}
WorkingDirectory=${dir}
ExecStart=${npx_path} next start -H 0.0.0.0 -p ${port}
Restart=on-failure
RestartSec=10
StandardOutput=journal
StandardError=journal
SyslogIdentifier=overseer
Environment=NODE_ENV=production
Environment=PORT=${port}
EnvironmentFile=${dir}/.env
NoNewPrivileges=true
ProtectSystem=strict
ReadWritePaths=${dir}
PrivateTmp=true

[Install]
WantedBy=multi-user.target
SVCEOF

    sudo systemctl daemon-reload
    echo -e "    ${GREEN}+${NC} Service file updated (next start on port ${port})"
}

# ---- Commands ----

cmd_start() {
    echo -e "${GREEN}Starting Overseer services...${NC}"
    if is_linux && command -v systemctl &>/dev/null; then
        sudo systemctl start overseer
        [ -n "${TELEGRAM_BOT_TOKEN:-}" ] && sudo systemctl start overseer-telegram 2>/dev/null || true
        [ -n "${DISCORD_BOT_TOKEN:-}" ] && sudo systemctl start overseer-discord 2>/dev/null || true
        [ "${WHATSAPP_ENABLED:-}" = "true" ] && sudo systemctl start overseer-whatsapp 2>/dev/null || true
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        launchctl load ~/Library/LaunchAgents/com.overseer.web.plist 2>/dev/null || true
    else
        echo "Starting manually..."
        PORT=$(get_port) npx next start -H 0.0.0.0 -p $(get_port) &
    fi
    echo -e "${GREEN}Started! Admin panel: http://$(get_ip):$(get_port)${NC}"
}

cmd_stop() {
    echo -e "${YELLOW}Stopping Overseer services...${NC}"
    if is_linux && command -v systemctl &>/dev/null; then
        sudo systemctl stop overseer overseer-telegram overseer-discord overseer-whatsapp 2>/dev/null || true
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        launchctl unload ~/Library/LaunchAgents/com.overseer.web.plist 2>/dev/null || true
    fi
    echo "Stopped."
}

cmd_restart() {
    cmd_stop
    sleep 2
    cmd_start
}

cmd_status() {
    echo -e "${CYAN}${BOLD}=== Overseer Status ===${NC}"
    echo ""
    if is_linux && command -v systemctl &>/dev/null; then
        for svc in overseer overseer-telegram overseer-discord overseer-whatsapp; do
            local status=$(systemctl is-active $svc 2>/dev/null || echo "inactive")
            local icon="[x]"
            [ "$status" = "active" ] && icon="[+]"
            echo "  $icon $svc: $status"
        done
    fi
    echo ""
    echo "  Admin: http://$(get_ip):$(get_port)"
}

cmd_logs() {
    local svc="${1:-}"
    if is_linux && command -v journalctl &>/dev/null; then
        if [ -n "$svc" ] && [ "$svc" != "web" ]; then
            sudo journalctl -u "overseer-${svc}" -f --no-hostname
        else
            sudo journalctl -u overseer -f --no-hostname
        fi
    else
        tail -f "$SCRIPT_DIR/logs/"*.log 2>/dev/null || echo "No log files found."
    fi
}

cmd_install_cli() {
    local target="/usr/local/bin/overseer"
    echo -e "${CYAN}${BOLD}Installing global Overseer command...${NC}"

    if [ -L "$target" ] || [ -e "$target" ]; then
        echo -e "${YELLOW}[WARN]${NC} $target already exists. Replacing it."
        sudo rm -f "$target"
    fi

    sudo ln -s "$SCRIPT_DIR/overseer" "$target"
    sudo chmod +x "$SCRIPT_DIR/overseer"

    echo -e "${GREEN}[OK]${NC} Global command installed."
    echo -e "  You can now run: ${BOLD}overseer status${NC} from any directory"
}

cmd_uninstall_cli() {
    local target="/usr/local/bin/overseer"
    echo -e "${CYAN}${BOLD}Removing global Overseer command...${NC}"

    if [ -L "$target" ] || [ -e "$target" ]; then
        sudo rm -f "$target"
        echo -e "${GREEN}[OK]${NC} Removed $target"
    else
        echo -e "${YELLOW}[WARN]${NC} No global overseer command found at $target"
    fi
}

cmd_update_check() {
    echo -e "${CYAN}${BOLD}Checking for Overseer updates...${NC}"
    echo ""

    check_for_updates

    case "$UPDATE_STATUS" in
        up-to-date)
            echo -e "${GREEN}[OK]${NC} Already up-to-date (${UPDATE_LOCAL_SHA:0:8})."
            ;;
        behind)
            echo -e "${YELLOW}[UPDATE AVAILABLE]${NC} New commits found on ${UPDATE_REMOTE}/${UPDATE_BRANCH}."
            echo -e "  Local:  ${UPDATE_LOCAL_SHA:0:8}"
            echo -e "  Remote: ${UPDATE_REMOTE_SHA:0:8}"
            ;;
        ahead)
            echo -e "${YELLOW}[INFO]${NC} Local branch is ahead of ${UPDATE_REMOTE}/${UPDATE_BRANCH}."
            echo -e "  Local:  ${UPDATE_LOCAL_SHA:0:8}"
            echo -e "  Remote: ${UPDATE_REMOTE_SHA:0:8}"
            ;;
        diverged)
            echo -e "${RED}[WARN]${NC} Local and remote branches have diverged."
            echo -e "  Local:  ${UPDATE_LOCAL_SHA:0:8}"
            echo -e "  Remote: ${UPDATE_REMOTE_SHA:0:8}"
            ;;
        not-git)
            echo -e "${YELLOW}[WARN]${NC} This directory is not a git repository; update check unavailable."
            ;;
        fetch-failed)
            echo -e "${RED}[ERROR]${NC} Failed to fetch from ${UPDATE_REMOTE}/${UPDATE_BRANCH}."
            ;;
    esac
}

cmd_update() {
    local force_update="${1:-false}"
    echo -e "${CYAN}${BOLD}Updating Overseer...${NC}"
    echo ""

    # 1. Check if updates are available
    check_for_updates

    case "$UPDATE_STATUS" in
        up-to-date)
            echo -e "${GREEN}[OK]${NC} No updates available. Already on latest commit (${UPDATE_LOCAL_SHA:0:8})."
            return 0
            ;;
        ahead)
            echo -e "${YELLOW}[INFO]${NC} Local branch is ahead of ${UPDATE_REMOTE}/${UPDATE_BRANCH}; no remote updates to apply."
            return 0
            ;;
        diverged)
            if [ "$force_update" != "true" ]; then
                echo -e "${RED}[WARN]${NC} Local and remote branches diverged. Resolve manually or run: ./overseer update --force"
                return 1
            fi
            echo -e "${YELLOW}[FORCE]${NC} Branch has diverged; attempting forced update path."
            ;;
        not-git)
            echo -e "${RED}[ERROR]${NC} This folder is not a git repository. Cannot perform update."
            return 1
            ;;
        fetch-failed)
            echo -e "${RED}[ERROR]${NC} Could not fetch updates from ${UPDATE_REMOTE}/${UPDATE_BRANCH}."
            return 1
            ;;
        behind)
            echo -e "${BLUE}==>${NC} Updates detected on ${UPDATE_REMOTE}/${UPDATE_BRANCH}"
            ;;
    esac

    # 2. Pull latest code (this also updates THIS script)
    echo -e "${BLUE}==>${NC} Pulling latest code..."

    local had_stash="false"
    if [ -n "$(git status --porcelain)" ]; then
        git stash push -u -m "overseer-auto-stash-$(date +%s)" >/dev/null 2>&1 || true
        had_stash="true"
    fi

    local old_sha="$UPDATE_LOCAL_SHA"
    if ! git pull --ff-only "$UPDATE_REMOTE" "$UPDATE_BRANCH"; then
        echo -e "${RED}[ERROR]${NC} Failed to fast-forward. Resolve git state and retry."
        if [ "$had_stash" = "true" ]; then
            git stash pop >/dev/null 2>&1 || true
        fi
        return 1
    fi

    if [ "$had_stash" = "true" ]; then
        git stash pop >/dev/null 2>&1 || true
    fi

    local new_sha
    new_sha=$(git rev-parse HEAD)

    if [ "$old_sha" = "$new_sha" ]; then
        echo -e "${GREEN}[OK]${NC} Pull completed, but no new commit was applied."
        return 0
    fi

    echo -e "    ${GREEN}+${NC} Updated ${old_sha:0:8} -> ${new_sha:0:8}"
    echo ""

    local changed_files
    changed_files=$(git diff --name-only "$old_sha" "$new_sha")

    local needs_install="false"
    local needs_db="false"
    local needs_build="false"

    while IFS= read -r file; do
        [ -z "$file" ] && continue
        case "$file" in
            package.json|pnpm-lock.yaml|package-lock.json|yarn.lock)
                needs_install="true"
                ;;
        esac

        case "$file" in
            src/database/*|src/database/*/*|data/*)
                needs_db="true"
                ;;
        esac

        case "$file" in
            docs/*|*.md|LICENSE)
                ;;
            *)
                needs_build="true"
                ;;
        esac
    done <<< "$changed_files"

    # 3. Install dependencies (only if lockfiles/package changed)
    if [ "$needs_install" = "true" ]; then
        echo -e "${BLUE}==>${NC} Installing dependencies..."
        if command -v pnpm &>/dev/null; then
            pnpm install --no-frozen-lockfile
        else
            npm install
        fi
        echo ""
    else
        echo -e "${BLUE}==>${NC} Skipping dependency install (no lockfile/package changes)."
        echo ""
    fi

    # 4. Run database migrations when database-related files changed
    if [ "$needs_db" = "true" ]; then
        echo -e "${BLUE}==>${NC} Running database migrations..."
        if command -v pnpm &>/dev/null; then
            pnpm run db:init 2>&1 || true
        else
            npm run db:init 2>&1 || true
        fi
        echo ""
    else
        echo -e "${BLUE}==>${NC} Skipping database migrations (no DB changes detected)."
        echo ""
    fi

    # 5. Build and restart only when runtime-affecting changes exist
    if [ "$needs_build" = "true" ]; then
        echo -e "${BLUE}==>${NC} Building application..."
        rm -rf .next
        if command -v pnpm &>/dev/null; then
            pnpm run build
        else
            npm run build
        fi

        if [ ! -d ".next" ]; then
            echo -e "${RED}Build failed!${NC}"
            exit 1
        fi
        echo ""

        # 6. Regenerate systemd service (ensures it matches current config)
        echo -e "${BLUE}==>${NC} Updating system service..."
        regenerate_systemd_service

        # 7. Restart
        echo -e "${BLUE}==>${NC} Restarting services..."
        cmd_stop
        sleep 2
        cmd_start
    else
        echo -e "${BLUE}==>${NC} Runtime unchanged (docs/meta-only update). Skipping build and restart."
    fi

    echo ""
    echo -e "${GREEN}${BOLD}Update complete!${NC}"
    echo -e "  Admin: http://$(get_ip):$(get_port)"
}

cmd_help() {
    echo -e "${BOLD}Overseer Management${NC}"
    echo ""
    echo "Usage: ./overseer <command>"
    echo ""
    echo "Commands:"
    echo "  start     Start all configured services"
    echo "  stop      Stop all services"
    echo "  restart   Restart all services"
    echo "  status    Show service status"
    echo "  logs      View logs (logs web|telegram|discord|whatsapp)"
    echo "  update    Update to latest version (only applies when new commits exist)"
    echo "  update --check  Check if updates are available"
    echo "  update --force  Attempt update even if branch diverged"
    echo "  install-cli     Install global 'overseer' command"
    echo "  uninstall-cli   Remove global 'overseer' command"
    echo "  help      Show this help"
}

case "${1:-help}" in
    start)   cmd_start ;;
    stop)    cmd_stop ;;
    restart) cmd_restart ;;
    status)  cmd_status ;;
    logs)    cmd_logs "${2:-}" ;;
    install-cli) cmd_install_cli ;;
    uninstall-cli) cmd_uninstall_cli ;;
    update)
        case "${2:-}" in
            --check|-c) cmd_update_check ;;
            --force|-f) cmd_update true ;;
            *) cmd_update ;;
        esac
        ;;
    help|*)  cmd_help ;;
esac
